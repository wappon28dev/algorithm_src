# ２年学年末 アルゴリズムまとめ

## 目次

<details><summary>クリック/タップ して目次を表示</summary><div>

- [２年学年末 アルゴリズムまとめ](#２年学年末-アルゴリズムまとめ)
  - [目次](#目次)
  - [5-3 スタックとキュー](#5-3-スタックとキュー)
    - [☆ スタックとキューとは](#-スタックとキューとは)
      - [スタック](#スタック)
      - [キュー](#キュー)
      - [スタックとキューの違い](#スタックとキューの違い)
    - [☆ さらに詳しく](#-さらに詳しく)
      - [スタック](#スタック-1)
      - [キュー](#キュー-1)
    - [☆ 書き方](#-書き方)
      - [スタック](#スタック-2)
      - [キュー](#キュー-2)
    - [☆ 教科書問題](#-教科書問題)
      - [スタックに文字を格納する](#スタックに文字を格納する)
      - [キューに文字を格納する](#キューに文字を格納する)
      - [５章 章末問題](#５章-章末問題)
  - [6-1 探索](#6-1-探索)
    - [☆ 探索とは](#-探索とは)
    - [☆ さらに詳しく](#-さらに詳しく-1)
      - [線形探索](#線形探索)
      - [二分探索](#二分探索)
    - [☆ 教科書問題](#-教科書問題-1)
  - [6-2 線形探索](#6-2-線形探索)
    - [☆ 線形探索 とは](#-線形探索-とは)
    - [☆ さらに詳しく](#-さらに詳しく-2)
    - [☆ 書き方](#-書き方-1)
    - [☆ 教科書問題](#-教科書問題-2)
      - [線形探索による単語帳からの単語の検索](#線形探索による単語帳からの単語の検索)
  - [6-3 二分探索](#6-3-二分探索)
    - [☆ 二分探索 とは](#-二分探索-とは)
    - [☆ さらに詳しく](#-さらに詳しく-3)
    - [☆ 書き方](#-書き方-2)
    - [☆ 教科書問題](#-教科書問題-3)
      - [二分探索による単語帳からの探索](#二分探索による単語帳からの探索)
      - [６章 章末問題](#６章-章末問題)
  - [7-1 整列](#7-1-整列)
    - [☆ 整列とは](#-整列とは)
    - [☆ さらに詳しく](#-さらに詳しく-4)
  - [7-2 交換法](#7-2-交換法)
    - [☆ 交換法 とは](#-交換法-とは)
    - [☆ さらに詳しく](#-さらに詳しく-5)
    - [☆ 書き方](#-書き方-3)
    - [☆ 教科書問題](#-教科書問題-4)
      - [交換法による数値の並び替え](#交換法による数値の並び替え)
  - [7-3 選択法 とは](#7-3-選択法-とは)
    - [☆ 選択法 とは](#-選択法-とは)
    - [☆ さらに詳しく](#-さらに詳しく-6)
    - [☆ 書き方](#-書き方-4)
    - [☆ 教科書問題](#-教科書問題-5)
      - [選択法による数値の並び替え](#選択法による数値の並び替え)
      - [７章 章末問題](#７章-章末問題)
  - [P.S.](#ps)
    - [strcmp ってなんなのよ](#strcmp-ってなんなのよ)
      - [書き方, 戻り値](#書き方-戻り値)
      - [コードブロックの解説](#コードブロックの解説)
    - [交換アルゴリズム](#交換アルゴリズム)
  - [ref](#ref)

</div></details>

## 5-3 スタックとキュー

### ☆ スタックとキューとは

#### スタック

上へ上へと積み重ねてデータを格納していくようなデータ構造を **スタック (stack)** という.  
最後に格納したデータから順番に取り出していく → **後入れ先出し方式 (LIFO/Last-In First-Out)**

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200112111826.gif)

#### キュー

並んでいる列のようにデータを格納していくようなデータ構造を **キュー (queue)** という.  
最初に格納したデータから順番に取り出していく → **先入れ先出し方式 (FIFO/First-In First-Out)**

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200112111822.gif)

#### スタックとキューの違い

アニメーションは世界を救う

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20191025081622.gif)

### ☆ さらに詳しく

#### スタック

スタックにデータを格納することを **プッシュ (push)** という.  
また, スタックからデータを取り出すことを **ポップ (pop)** という.

- プッシュとポップの２つの操作だけでデータの出し入れが行える.  
  → プログラムを完結にすることができる

- スタックに格納されたデータは, 一番上にあるデータから順番に取り出される.  
  → スタックの途中に格納されたデータに自由にアクセスすることはできない

データを格納するための領域 ~~(スタック領域)~~ は, 予想よりも余裕をもって設定する必要がある.  
スタック領域を使って多くデータを格納すると, (スタック) **オーバーフロー (overflow)** が起きる.  
また, スタック領域からデータを多く取り出そうとすると, (スタック) **アンダーフロー (underflow)** が起きる.

|                    | index | value |
| -----------------: | :---: | ----- |
|                    |   5   |       |
|                    |   4   |       |
| スタックポインタ → |   3   | ←←← D |
|              (top) |   2   | C     |
|                    |   1   | B     |
|           (bottom) |   0   | A     |

&emsp;&emsp;&emsp;&emsp;&emsp;stack&emsp;↓↓↓&emsp;スタックポインタを１増やす

|                    | index | value |
| -----------------: | :---: | ----- |
|                    |   5   |       |
| スタックポインタ → |   4   |       |
|              (top) |   3   | D     |
|                    |   2   | C     |
|                    |   1   | B     |
|           (bottom) |   0   | A     |

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;pop&emsp;↓↓↓&emsp;スタックポインタを１減らす

|                    | index | value |
| -----------------: | :---: | ----- |
|                    |   5   |       |
|                    |   4   |       |
| スタックポインタ → |   3   | →→→ D |
|              (top) |   2   | C     |
|                    |   1   | B     |
|           (bottom) |   0   | A     |

#### キュー

キューにデータを格納することを **エンキュー (enqueue)** という.  
キューからデータを取り出すことを **デキュー (dequeue)** という.

- キューは１つのデータの処理が終わる前に次のデータを送られてきても, そのデータを格納しておくことができる.  
  → キューを使ってデータをためると, そのデータを順番に処理することができる

- キューに格納されたデータは, 一番最初に格納されたデータから順番に取り出される.  
  → キューの途中に格納されたデータに自由にアクセスすることはできない

スタックと同じように, キューでもオーバーフローやアンダーフローを起こさないようにする必要がある.  
キューでは末尾ポインタがデータ数に応じて進むので, スタックよりもデータ領域の消費が速い.

先頭/末尾 ポインタが記憶領域の端に来たら, 先頭に戻して記憶領域を再利用することを **リングバッファ (ring buffer)** という.

(あのえっと, SD カードとかで容量が無くなったら古いやつを上書きされるあれの感覚)

<br />

|                | index | value |
| -------------: | :---: | ----- |
|                |   0   |       |
| 先頭ポインタ → |   1   | A     |
|                |   2   | B     |
|                |   3   | C     |
| 末尾ポインタ → |   4   | ←←← D |
|                |   5   |       |

&emsp;&emsp;&emsp;&emsp;&emsp;enqueue&emsp;↓↓↓&emsp;末尾ポインタを 1 増やす

|                | index | value |
| -------------: | :---: | ----- |
|                |   0   |       |
| 先頭ポインタ → |   1   | A     |
|                |   2   | B     |
|                |   3   | C     |
|                |   4   | D     |
| 末尾ポインタ → |   5   |       |

&emsp;&emsp;&emsp;&emsp;&emsp;dequeue&emsp;↓↓↓&emsp;先頭ポインタを 1 増やす

|                | index | value |
| -------------: | :---: | ----- |
|                |   0   |       |
|                |   1   | →→→ A |
| 先頭ポインタ → |   2   | B     |
|                |   3   | C     |
|                |   4   | D     |
| 末尾ポインタ → |   5   |       |

### ☆ 書き方

#### スタック

- スタックにデータを格納するための下ごしらえ

  1. データを格納する配列を用意する
  2. 次のデータを格納する配列の, 末尾からの添字 (**スタックポインタ (stack pointer)**) を宣言する

- スタックするには...？

  1. 配列の `スタックポインタ` 番目 (`data[stackPointer]`) にデータを格納する
  2. `スタックポインタ` の値を 1 増やす

- ポップするには...？
  1. `スタックポインタ` の値を 1 減らす
  2. 配列の `スタックポインタ` 番目 (`data[stackPointer]`) のデータを取り出す

#### キュー

- キューにデータを格納するための下ごしらえ

  1. データを格納する配列を用意する
  2. 次のデータを格納する配列の添字 (**末尾ポインタ (tail)**) を宣言する
  3. 次に取り出すデータの配列の添字 (**先頭ポインタ (head)**) を宣言する

- エンキューするには...？

  1. 配列の `末尾ポインタ` 番目 (`data[tailPointer]`) にデータを格納する
  2. `末尾ポインタ` の値を 1 増やす

- デーキューするには...？

  1. 配列の `先頭ポインタ` 番目 (`data[headPointer]`) のデータを取り出す
  2. `先頭ポインタ` の値を 1 増やす

### ☆ 教科書問題

#### スタックに文字を格納する

- [例題１](./p130_r1.c)
  - [練習問題](./p131_ren.c)
    - [いじいじ](./p131_ren_mod.c)

#### キューに文字を格納する

- [例題２](./p131_r2.c)
  - [練習問題](./p132_ren.c)

#### ５章 章末問題

- [3](./p131_ren_mod.c): おおむねこれ
- 4: S / Q / Q

## 6-1 探索

### ☆ 探索とは

**探索 (search)** とは, データの集合の中から指定されたデータを探し出す手法である.  
コンピュータがプログラムによりデータを処理する際に, 多くのデータの中から必要なデータを取り出すことは最も基本的な処理である.  
そのため, 探索を行うための手順や方法である **探索アルゴリズム (search algorithm)** は, たくさんある.

(課題研究であった通り, 地図から最短距離を求める A\* アルゴリズム (A\* algorithm) も有名な探索アルゴリズムの一つだよ)

探索において, 探し出そうとするデータを **キー (key)** という.  
探索アルゴリズムは, キーを探し出すことができれば, そのキーに対応するデータを探し出すことができる.  
また, 目的のデータが...

- 存在する場合: **成功探索 (successful search)**
- 存在しない場合: **失敗探索 (unsuccessful search)**

という.

### ☆ さらに詳しく

今回は, 以下の探索アルゴリズムを学ぶ.

#### 線形探索

**線形探索 (linear search/sequential search)** とは, データの集合の先頭から順に, キーと一致するデータを探し出す手法である.  
プログラムは単純であるが, 目的のデータが最後にある場合には, すべてのデータを調べる必要がある.

#### 二分探索

**二分探索 (binary search)** とは, データの集合を, キーの大小でソートした後に, キーと一致するデータを探し出す手法である.  
探索範囲を半分に絞り込むことができるので, 探索を高速化することができるが, 並び替えの作業を含めると線形探索よりも処理が増える.

### ☆ 教科書問題

なし

## 6-2 線形探索

### ☆ 線形探索 とは

上見ろ ([戻る](#線形探索))

### ☆ さらに詳しく

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200112231008.gif)

先頭 (0 番目) の配列から順に, キーと一致するかどうかを順番にチェックする.

- キーと一致するデータ見つけられたら, 探索成功
- 最後まで一致しなかったら, 探索失敗

のようになる.

### ☆ 書き方

配列 `data` で管理しているデータの中から, キー `key` と一致するデータを探索するプログラムを書く.

1. `i` を 0 (配列の先頭) に初期化する
2. `i` が `data` の要素数より小さい間 (`i` < `data.length`), 以下の処理を繰り返す:
   1. `data` の `i` 番目 (`data[i]`) が `key` と一致するかどうかをチェックする
   2. 一致したら, `i` を返す
   3. 一致しなかったら, `i` を 1 増やす

単純明快.

### ☆ 教科書問題

#### 線形探索による単語帳からの単語の検索

- [例題１](./p142_r1.c)
  - [いじいじ](./p142_r1_mod.c)
- [練習問題](./p143_ren.c)

## 6-3 二分探索

### ☆ 二分探索 とは

上見ろ ([戻る](#二分探索))

### ☆ さらに詳しく

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200112231100.gif)

整列済みのデータに対して, 探索する範囲を半分に絞り込みながら, キーと一致するかどうかを順番にチェックする.

- 目的のキーと一致したら, 探索成功
- 探索範囲が存在しなくなったら, 探索失敗

のようになる.

### ☆ 書き方

配列 `data` で管理しているデータの中から, キー `key` と一致するデータを探索するプログラムを書く.

1. 配列の添字 `low` を, 探索範囲の先頭 (0 番目) に初期化
2. 配列の添字 `high` を, 探索範囲の末尾 (`data.length - 1`) に初期化
3. `low` が `high` 以下のとき (`low` <= `high`), 以下の処理を繰り返す:
   1. 探索範囲の中央の添字 `mid` を求める
   2. `data` の `mid` 番目 (`data[mid]`) が `key` と一致するかどうかをチェックする
   3. 一致したら, `mid` を返す
   4. 一致しなかったら, `key` と `data[mid]` を比較する:
      - `key` が `data[mid]` より小さい (小さい方のデータが前にある / `key < data[mid]` ) 場合:
        - 探索範囲を `high` から `mid - 1` に絞り込む
      - `key` が `data[mid]` より大きい (大きい方のデータが後ろにある / `key > data[mid]` ) 場合:
        - 探索範囲を `low` から `mid + 1` に絞り込む

### ☆ 教科書問題

#### 二分探索による単語帳からの探索

- [例題１](./p150_r1.c)
  - [いじいじ](./p150_r1_mod.c)
- [練習問題](./p151_ren.c)
  - [いじいじ](./p151_ren_mod.c)

#### ６章 章末問題

- [1](./p154_1.c)
- [2](./p151_ren_mod.c): おおむねこれ
- 3
  - [1](./p154_3_1.c)
  - [2](./p154_3_2.c)
  - [3](./p154_3_3.c)
- 4

  ```mermaid
  flowchart TB
  node_1(["始め"])
  node_2[/"探索値 key\n データ data\n データ数 n"/]
  node_3["middle = n / 2"]
  node_4[/"ループ\nlow ≦ high の間"\]
  node_5["mid = (low + high) / 2"]
  node_6{"key #lt; data[mid]"}
  node_7["high = mid - 1"]
  node_8{"key #gt; data[mid]"}
  node_9["low = mid + 1"]
  node_10["一致処理"]
  node_11[\"ループ"/]
  node_12(["終わり"])
  node_1 --> node_2
  node_2 --> node_3
  node_3 --> node_4
  node_4 --> node_5
  node_5 --> node_6
  node_6 --"YES"--> node_7
  node_6 --"NO"--> node_8
  node_8 --"YES"--> node_9
  node_8 --"NO"--> node_10
  node_7 --> node_11
  node_9 --> node_11
  node_11 --> node_12
  node_10 --> node_12
  ```

## 7-1 整列

### ☆ 整列とは

**整列 (sort)** とは, 与えられたデータを一定の規則に従って並べ替える手法である.  
順番として, **昇順** ( 小さい順 / ascending order ) と**降順** ( 大きい順 / descending order ) がある.  
また, 並び替えの基準となる項目を **ソートキー (sort key)** と呼ぶ.

### ☆ さらに詳しく

今回は, 以下の探索アルゴリズムを学ぶ.

| 名称       | 特徴                                                        |
| ---------- | ----------------------------------------------------------- |
| 交換法     | 隣接するデータを比較して, 順番に基づき交換する              |
| 選択法     | データの中から最小値 (最大値) を選択して交換する            |
| ~~挿入法~~ | ~~整列状態を保つ位置にデータを挿入していく~~ (テスト範囲外) |

## 7-2 交換法

### ☆ 交換法 とは

**交換法 (bubble sort/exchange sort)** とは, 隣接するデータの大小を比較して, 逆順の場合に交換を繰り返して並び替えを行う手法である.

![](https://user-images.githubusercontent.com/86721991/221938643-1a49155b-99be-4564-9b4a-98029d37bda9.png)

~~配列の後ろのほうから min or max が確定されるから, 正規の方法だと, 後ろから走査するんだけどね~~

### ☆ さらに詳しく

隣接するデータの比較と交換を先頭から最後まで行うと, 最後のデータは 最大/最小 値になる.  
そのため, 次のループでは, 最後のデータは比較対象から外すことができる.  
これを繰り返すことで, 並び替えが完了する.

### ☆ 書き方

配列 `data` で管理している `n` 個のデータを, 交換法により昇順に並べ替えるプログラムを書く:

1. 整列範囲のデータ数 `i` を, 配列の総素数 `n` に初期化する.
2. 整列範囲のデータ数 `i` が 1 より大きい間 (`i > 1`), 以下の処理を繰り返す.
   1. 配列の添字 `j` を先頭の次 (`1`) に初期化
   2. `j` が `i` より小さい間 (`j < i`), 以下の処理を繰り返す
      1. `data[j - 1]` と `data[j]` を比較し, 逆順の場合に交換する
         - 昇順: `data[j - 1] > data[j]`
         - 降順: `data[j - 1] < data[j]`
      2. `j` に 1 を足す

### ☆ 教科書問題

#### 交換法による数値の並び替え

- [例題１](./p160_r1.c)
- [練習問題](./p161_ren.c)
  - [降順にするには...？](./p161_ren_reorder.c)

## 7-3 選択法 とは

### ☆ 選択法 とは

**選択法 (selection sort)** とは, 最小/最大 値を順次選択して並べ替えを行う手法である.

![](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200123091351.gif)

### ☆ さらに詳しく

整列範囲の先頭から最後までデータを調べて最小値を調べて 最小/最大 値を選択し, この結果と先頭を交換する.  
これによって, 先頭から順に 最小/最大 値が確定していく. 整列範囲がなくなるまでこの処理を行うと, 並び替えが完了する.

### ☆ 書き方

配列 `data` で管理している `n` 個のデータを, 交換法により並べ替えるプログラムを書く:

1. 配列の添字 `i` を先頭 (`0`) に初期化
2. `i` が `n - 1` より小さい間 (`i < n - 1`), 以下の処理を繰り返す

   1. 最小値のデータの添字を指す `min` を `i` に初期化

      - 降順なら, `max` だね

   2. `j` が `n` より小さい間 (`j < n`), 以下の処理を繰り返す:

      - `j = i + 1` から始めるよ

      1. `data[i]` と `data[j]` を比較し, 下の条件で(最大/最小 を見つけたら), `min` を `j` に更新する

         - 昇順: `data[i] > data[j]`
         - 降順: `data[i] < data[j]`

      2. `j` に 1 を足す

   3. `data[i]` と `data[min]` を交換する

      - 降順なら, `data[max]` だね

   4. `i` に 1 を足す

### ☆ 教科書問題

#### 選択法による数値の並び替え

- [例題１](./p166_r1.c)
- [練習問題](./p166_ren.c)

#### ７章 章末問題

- [1](./p176_r1.c)
- [2](./p176_r2.c): 選択法のみ

- 4

  ```mermaid
  flowchart TB
  node_1(["始め"])
  node_4[/"ループ1\ni = n - 1 から 1\nまで繰り返し"\]
  node_2[/"ループ2\nj = 1 から n \nまで繰り返し"\]
  node_3{"a[j - 1] #gt; a[j]"}
  node_5["a[j - 1] と a[j] の入れ替え"]
  node_6[\"ループ2\nj ← j + 1"/]
  node_7[\"ループ1\ni ← i - 1"/]
  node_1 --> node_4
  node_4 --> node_2
  node_2 --> node_3
  node_3 --"YES"--> node_5
  node_5 --> node_6
  node_6 --> node_7
  node_3 --"NO"--> node_6
  ```

## P.S.

### strcmp ってなんなのよ

string(文字列) comparative(比較) ってことで, 文字列を比較する関数.  
いや, どちらかというと引数に入れた２つの文字列の **文字コード上の** 大小を比較するよ.

#### 書き方, 戻り値

```c
strcmp(char *s1, char *s2)
```

- `string.h` を include するのを忘れずに
- 文字列を引数として渡す場合は, ポインタ参照の `*` をつけよう！

文字コード上で,

- `s1 < s2` -> `-1`
- `s1 = s2` -> `0`
- `s1 > s2` -> `1`

が返ってくるよ！

#### コードブロックの解説

線形探索や二分探索で使ったであろう...  
`key` と `word[i]` が同じ文字列なら, `i` を返すプログラム:  
https://github.com/wappon-28-dev/algorithm_src/blob/7cac6936b12916abe5c56ca4172a9a9939aa93c2/3rd_term/p142_r1_mod.c#L39-L50

1. まず `key` と `word[i]` はそれぞれ比較する文字列 (char) である.
2. もし, key と word[i] が同じ文字列なら, `0` を返す.
3. C 言語では, `0` は `false`, `1` は `true` となるので, `!` で真偽を反転させる

ちょっとわけわけして考えると...

```c
int bIsEqual = strcmp(key, word[i]) == 0;

if (bIsEqual) {
  return i;
}
```

のような書き方もできるよ. やったね！

### 交換アルゴリズム

交換法, 選択法 どちらでも, 値の入れ替えをするときがあるぞ.  
そのときに使うであろう, 一時変数を使った値の入れ替えのアルゴリズムを紹介するぞ.

https://github.com/wappon-28-dev/algorithm_src/blob/7cac6936b12916abe5c56ca4172a9a9939aa93c2/3rd_term/p160_r1.c#L44-L51

まあ... そのままだ...  
文字列でも数値でも渡せるのは良いとこだね

(落書き)

![](https://user-images.githubusercontent.com/86721991/222042778-1bd1a380-cda0-4f0b-b957-a94726a998a8.png)

<details><summary>ポインタを渡すのもありだぞ</summary><div>

```c
void Swap(int data[], int i, int j)
{
    int temp;

    temp = *data[i];
    *data[i] = *data[j];
    *data[j] = temp;
}
```

</div></details>

## ref

- [うさぎでもわかるスタックとキュー](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- [うさぎでもわかる探索アルゴリズム](https://www.momoyama-usagi.com/entry/info-algo-search)
- [一週間で身につくアルゴリズムとデータ構造](http://sevendays-study.com/algorithm/day5.html)
- [うさぎでもわかるソーティング　基本ソート編](https://www.momoyama-usagi.com/entry/info-algo-sort-basic)

おわり
