# ２年２学期期末 アルゴリズムまとめ

## 目次

<details><summary>クリック/タップ して目次を表示</summary><div>

- [２年２学期期末 アルゴリズムまとめ](#２年２学期期末-アルゴリズムまとめ)
  - [目次](#目次)
  - [3-1 配列](#3-1-配列)
    - [☆ 配列とは](#-配列とは)
    - [☆ さらに詳しく](#-さらに詳しく)
      - [1 - 2 次元配列](#1---2-次元配列)
      - [文字配列](#文字配列)
    - [☆ 書き方](#-書き方)
      - [１次元配列](#１次元配列)
      - [２次元配列](#２次元配列)
      - [文字配列](#文字配列-1)
    - [☆ 教科書問題](#-教科書問題)
      - [１次元配列の宣言とデータの格納](#１次元配列の宣言とデータの格納)
      - [定数を使用した１次元配列の宣言](#定数を使用した１次元配列の宣言)
      - [２次元配列へのデータの格納](#２次元配列へのデータの格納)
      - [２次元配列への文字データの格納](#２次元配列への文字データの格納)
      - [文字列処理関数を使った文字列の表示](#文字列処理関数を使った文字列の表示)
      - [３章 章末問題](#３章-章末問題)
    - [☆ 肝に銘じたほうが良いこと](#-肝に銘じたほうが良いこと)
  - [3-2 関数](#3-2-関数)
    - [☆ 関数とは](#-関数とは)
    - [☆ さらに詳しく](#-さらに詳しく-1)
      - [関数とサブルーチン](#関数とサブルーチン)
    - [☆ 書き方](#-書き方-1)
      - [引数なし, 戻り値なし の関数](#引数なし-戻り値なし-の関数)
      - [引数あり, 戻り値なし](#引数あり-戻り値なし)
      - [引数あり, 戻り値あり](#引数あり-戻り値あり)
      - [プロトタイプ宣言](#プロトタイプ宣言)
    - [☆ 教科書問題](#-教科書問題-1)
      - [関数の戻り値と引数を調べる](#関数の戻り値と引数を調べる)
      - [年齢による料金表示プログラムの関数化](#年齢による料金表示プログラムの関数化)
      - [変数の有効範囲の確認](#変数の有効範囲の確認)
  - [4-1 基本的な数値計算](#4-1-基本的な数値計算)
    - [☆ 合計・平均・分散・標準偏差とは](#-合計平均分散標準偏差とは)
      - [合計](#合計)
      - [平均](#平均)
      - [分散](#分散)
      - [標準偏差](#標準偏差)
    - [☆ 教科書問題](#-教科書問題-2)
      - [年間降水量と平均降水量を求める](#年間降水量と平均降水量を求める)
  - [4-2 アルゴリズムの工夫](#4-2-アルゴリズムの工夫)
    - [☆ 誤差の種類とは](#-誤差の種類とは)
    - [☆ 教科書問題](#-教科書問題-3)
      - [情報落ちの確認](#情報落ちの確認)
      - [降順と昇順の加算結果の比較](#降順と昇順の加算結果の比較)
  - [5-1 基本的なデータ構造](#5-1-基本的なデータ構造)
    - [☆ 配列とレコードとは](#-配列とレコードとは)
    - [☆ さらに詳しく](#-さらに詳しく-2)
      - [配列](#配列)
      - [レコード](#レコード)
    - [☆ 書き方](#-書き方-2)
      - [配列](#配列-1)
      - [レコード](#レコード-1)
    - [☆ 教科書問題](#-教科書問題-4)
      - [構造体配列への格納と一覧表示](#構造体配列への格納と一覧表示)
  - [5-2 リストと木構造](#5-2-リストと木構造)
    - [☆ リスト・木構造とは](#-リスト木構造とは)
      - [リスト](#リスト)
      - [木構造](#木構造)
    - [☆ さらに詳しく](#-さらに詳しく-3)
      - [リスト](#リスト-1)
      - [木構造](#木構造-1)
    - [☆ 書き方](#-書き方-3)
      - [リスト](#リスト-2)
        - [連結リストの表示](#連結リストの表示)
        - [リスト最後尾へのデータの追加](#リスト最後尾へのデータの追加)
      - [木構造](#木構造-2)
    - [☆ 教科書問題](#-教科書問題-5)
      - [構造体の配列を使ったリストのプログラム](#構造体の配列を使ったリストのプログラム)
      - [２分木に格納された文字の表示](#２分木に格納された文字の表示)

</div></details>

## 3-1 配列

### ☆ 配列とは

同じデータ型の複数の要素を１つにまとめたデータ構造のことを **配列 (array)** という.  
また, 配列を構成している要素を指定するには, それぞれの要素に付けられた **添字 (index)** と呼ばれる一連の番号を使用する.

### ☆ さらに詳しく

#### 1 - 2 次元配列

配列の要素を指定するには、配列名の後に, `()`や`[]`でくくって添字を付け, `a(3)`や`a[3]`のように表す.  
このように, 添え字が１つの配列を **１次元配列 (linear/1D array)** という.  
また, `a(2,3)`や`a[2][3]`のように, 配列の添字が２つある配列を **２次元配列 (2D array)** という.

#### 文字配列

C 言語で文字列 (string) を表すときは, 文字型の配列を利用して文字列を表す, データ領域は, `最大文字数 + 1` 分用意する.

### ☆ 書き方

#### １次元配列

```c
// １次元配列の宣言
int arr1d[6] = {1, 4, 1, 4, 2, 1};
```

`arr1d`の構造:
| index | 0 | 1 | 2 | 3 | 4 | 5 |
| ----- | --- | --- | --- | --- | --- | --- |
| value | `1` | `4` | `1` | `4` | `2` | `1` |

| 添字 (index) | アドレス (addr) | 中に入っている値 (value) |
| ------------ | --------------- | ------------------------ |
| 0            | `arr1d[0]`      | `1`                      |
| 1            | `arr1d[1]`      | `4`                      |
| 2            | `arr1d[2]`      | `1`                      |
| 3            | `arr1d[3]`      | `4`                      |
| 4            | `arr1d[4]`      | `2`                      |
| 5            | `arr1d[5]`      | `1`                      |
| 6            | `arr1d[6]`      | `\0`                     |

#### ２次元配列

```c
// ２次元配列の宣言
int arr2d[3][6] = {{1, 4, 1, 4, 2, 1}, {1, 7, 3, 2, 0, 5}, {2, 2, 3, 6, 0, 6}};
```

`arr2d`の構造:
| y\\x | 0 | 1 | 2 | 3 | 4 | 5 |
| ---- | --- | --- | --- | --- | --- | --- |
| 0 | `1` | `4` | `1` | `4` | `2` | `1` |
| 1 | `1` | `7` | `3` | `2` | `0` | `5` |
| 2 | `2` | `2` | `3` | `6` | `0` | `6` |

| y 添字 (index-y) | x 添字 (index-x) | アドレス (addr) | 中に入っている値 (value) |
| ---------------- | ---------------- | --------------- | ------------------------ |
| 0                | 0                | `arr1d[0][0]`   | `1`                      |
| 0                | 1                | `arr1d[0][1]`   | `4`                      |
| ︙               | ︙               | ︙              | ︙                       |
| 1                | 2                | `arr1d[1][2]`   | `3`                      |
| 1                | 3                | `arr1d[1][3]`   | `2`                      |
| ︙               | ︙               | ︙              | ︙                       |
| 2                | 4                | `arr1d[2][4]`   | `0`                      |
| 2                | 5                | `arr1d[2][5]`   | `6`                      |
| ︙               | ︙               | ︙              | ︙                       |
| 3                | 6                | `arr1d[3][6]`   | `\0`                     |

#### 文字配列

下のコードで宣言された値は, どれも同一である.

```c
// 文字数の明示指定
char str[6] = {'H', 'y', 'o', 'd', 'o', '\0'};
// 文字数の指定なし
char str[] = {'H', 'y', 'o', 'd', 'o', '\0'};
// ダブルクオーテーションで括ると, `\0` の必要なし
char str[] = "Hyodo";
```

| index | 0   | 1   | 2   | 3   | 4   | 5    |
| ----- | --- | --- | --- | --- | --- | ---- |
| value | `H` | `y` | `o` | `d` | `o` | `\0` |

### ☆ 教科書問題

#### １次元配列の宣言とデータの格納

-   [例題１](./p58_r1.c)
    -   [練習問題](./p58_ren.c)

#### 定数を使用した１次元配列の宣言

-   [例題２](./p59_r2.c)
    -   [練習問題](./p59_ren.c)

#### ２次元配列へのデータの格納

-   [例題３](./p60_r3.c)
    -   [練習問題](./p60_ren.c)
    -   [練習問題](./p60_ren2.c): １次元配列での宣言

#### ２次元配列への文字データの格納

-   [例題４](./p61_r4.c)
    -   [練習問題](./p61_ren.c)

#### 文字列処理関数を使った文字列の表示

-   [例題５](./p63_r5.c)

#### ３章 章末問題

-   [１](./p84_1.c)
-   [２](./p84_2.c)
-   [３](./p84_3.c)
-   [４](./p84_4.c): 自己流注意

### ☆ 肝に銘じたほうが良いこと

1. 配列は, **いくつかの変数をくっつけたもの** のような感じだ.
    > 同じデータ型なら, `int` でも `float` でも 言語によるが, 関数でさえも入れられるぞ.
1. お前はまず, **配列の添字は `0` から始まること**を忘れてはならない.

    > これは, 配列の最初に入っている値からの距離のことだと考えるとわかりやすいぞ.

1. 文字配列を宣言するときのサイズは, **`最大数 + 1`** だ. 忘れるな.

    > これは, 文字列の終端にヌル文字 `\0` を入れるからだ.  
    > 証明の終わりの`■`や`//`だと思え.

1. 文字列を操作する関数を呼び出すときは, **`string.h`の`include`を忘れずに** だ. いいな？

    > 文字列を操作する関数は, `strcpy`関数などのことだ.  
    > ちなみにこの関数は破壊的で, TypeScript で表すと

    ```ts
    function strcpy(a: string, b: string): void {
        a += b;
    }
    ```

    > のような感じだ. 考えるな, よく読んで感じろ.

1. ２次元配列の回転が怖い？ **これは覚えろ**

    > 縦と横の長さである 6 を 定数 `HW` として宣言すると,

    ```c
     char c[HW][HW] = {
         {' ', ' ', ' ', ' ', ' ', ' '},
         {' ', '*', '*', '*', '*', '*'},
         {' ', '*', '*', '*', '*', ' '},
         {' ', '*', '*', '*', ' ', ' '},
         {' ', '*', '*', ' ', ' ', ' '},
         {' ', '*', ' ', ' ', ' ', ' '},
     };

     int i, j;

     for (i = 1; i <= 5; i++)        // または, i <= (HW) - 1
     {
         for (j = 1; j <= 5; j++)    // または, i <= (HW) - 1
         {
             printf("%c ", /* foo */);
         }
         printf("\n");
     }
    ```

    `foo`について:
    | 回転 (左回り) | 変数名 | コメント |
    | ------------- | ---------------------------------------------------------------- | ------------------------- |
    | 0 | `c[i][j]` | そのままだ |
    | 90° | `c[j][5 - (i - 1)]` <br /> または, `c[j][HW - i]` | 逆にして`x(i)` をいじる |
    | 180° | `c[5 - (i - 1)][5 - (j - 1)]` <br /> または, `c[HW - i][HW - j]` | `i`, `j` をそれぞれいじる |
    | 270° | `c[5 - (j - 1)][i]` <br /> または, `c[HW - j][i]` | 逆にして `y(j)` をいじる |

    ```
        0°                90°                  180°                 270°

     * * * * *          *                            *             * * * * *
     * * * *            * *                        * *               * * * *
     * * *              * * *                    * * *                 * * *
     * *                * * * *                * * * *                   * *
     *                  * * * * *            * * * * *                     *

      [i][j]           [j][HW - i]        [HW - i][HW - j]         [HW - j][i]
    ```

    [FULL](./p84_4.c)

     <details><summary>茶番</summary><div>

    教科書だと最初に余白を付けているせいで, ややこしくなっている.  
     本来ならばそんな難しくないぞ...

    縦と横の長さである 5 を 定数 `HW` として宣言すると,

    ```c
     char character[HW][HW] = {
         {'*', '*', '*', '*', '*'},
         {'*', '*', '*', '*', ' '},
         {'*', '*', '*', ' ', ' '},
         {'*', '*', ' ', ' ', ' '},
         {'*', ' ', ' ', ' ', ' '},
     };

     int i, j;

     for (i = 0; i < HW; i++)
     {
         for (j = 0; j < HW; j++)
         {
             printf("%c ", /* foo */);
         }
         printf("\n");
     }
    ```

    `foo`について:
    | 回転 (左回り) | 変数名 | コメント |
    | ------------- | --------------------------- | ------------------------- |
    | 0 | `c[i][j]` | そのままだ |
    | 90° | `c[j][HW - 1 - i]` | 逆にして `x(i)` をいじる |
    | 180° | `c[HW - 1 - i][HW - 1 - j]` | `i`, `j` をそれぞれいじる |
    | 270° | `c[HW - 1 - j][i]` | 逆にして `y(j)` をいじる |

    ```
        0°                90°                  180°                 270°

     * * * * *          *                            *             * * * * *
     * * * *            * *                        * *               * * * *
     * * *              * * *                    * * *                 * * *
     * *                * * * *                * * * *                   * *
     *                  * * * * *            * * * * *                     *

      [i][j]        [j][HW - 1 - i]    [HW - 1 - i][HW - 1 - j]   [HW - 1 - j][i]
    ```

    [FULL](./p84_4_mod.c)

    ほら簡単で単純だろ？ だが, たぶん余白があるせいでこれは使えない...残念だ...

    </div></details>

## 3-2 関数

### ☆ 関数とは

実用的なプログラムを作ろうとすると, プログラムが長くなり, 全体がわかりにくいものになってしまうことが多い.  
プログラム中で同じような処理を何度も行う場合, **関数 (function)** や **サブルーチン (subroutine)** に分けておく.  
関数やサブルーチンなどの副プログラムに渡す値を **引数 (arguments)** という.

### ☆ さらに詳しく

#### 関数とサブルーチン

戻り値がある副プログラムを **関数** といい, 戻り値のない副プログラムは **サブルーチン** という.  
また, 多くのプログラム言語では, プログラム全体で共通して使える **大域/グローバル 変数 (global variables)** と  
副プログラムの中だけで使える **局所/ローカル 変数 (local variables)** という.  
このような変数が有効な範囲を **スコープ (scope)** という.

### ☆ 書き方

#### 引数なし, 戻り値なし の関数

```c
void askNums(void)
{
    int a, b;

    printf("a   => ");
    scanf("%d", &a);
    printf("b   => ");
    scanf("%d", &b);

    printf("sum => %d\n", a + b);
}

// 呼び出し: askNums(); -> void
```

#### 引数あり, 戻り値なし

```c
void showSum(int a, int b)
{
    printf("sum => %d\n", a + b);
}
// 呼び出し: showSum(3, 5); -> void
```

#### 引数あり, 戻り値あり

```c
int calculateSum(int a, int b) { return a + b; }
// 呼び出し: calculateSum(3, 5); -> 8
```

#### プロトタイプ宣言

上の関数のプロトタイプ宣言:

```c
#include <stdio.h>

int calculateSum(int a, int b); // <- こ↑こ↓

int main(){
    ...
}

...

int calculateSum(int a, int b){
    ...
}
```

関数の処理を書かないバージョンだと思えば良い.  
abstract みたいだね (小声)  
main 関数の前 (使う関数の前) にプロトタイプ宣言を置こう.

### ☆ 教科書問題

#### 関数の戻り値と引数を調べる

-   [例題 1-1](./p70_r1_1.c)
-   [例題 1-2](./p70_r1_2.c)
-   [例題 1-3](./p70_r1_3.c)
    -   [練習問題](./p71_ren.c)

#### 年齢による料金表示プログラムの関数化

-   [例題２](./p72_r2.c)
    -   [練習問題](./p72_ren.c)

#### 変数の有効範囲の確認

-   [例題３](./p73_r3.c)

## 4-1 基本的な数値計算

### ☆ 合計・平均・分散・標準偏差とは

覚えなくて良いから, 省略.

<details><summary>見たい方はどうぞ</summary><div>

#### 合計

値の総和を **合計 (sum)** という.

$$
        合計 = 入力データの総和
$$

#### 平均

$$
    平均 = \frac{入力データの総和}{入力データ数} = \frac{合計}{入力データ数}
$$

#### 分散

**分散 (variance)** は, それぞれの入力データと平均値との差を求め, その２乗の総和を入力データ数で割ったものである.

$$
    分散 = \frac{(入力データ - 平均値)^2の総和}{入力データ数} = \frac{(入力データ)^2の総和}{入力データ数} - (平均値)^2
$$

#### 標準偏差

**標準偏差 (SD)** は, 分散の正の平方根である.

$$
    標準偏差 = \sqrt{分散}
$$

</div></details>

### ☆ 教科書問題

#### 年間降水量と平均降水量を求める

-   [例題１](./p88_r1.c)
-   [例題２](./p89_r2.c)
    -   [練習問題](./p89_ren.c)

## 4-2 アルゴリズムの工夫

### ☆ 誤差の種類とは

実際の解 (**真値 (true value)**) と **近似値 (approximate value)** (コンピュータなどで計算した値) との差を  
**誤差 (error)** あるいは **絶対誤差 (absolute error)** という.  
誤差には以下の種類がある.

| 誤差の種類 | 説明                                                                                                        |
| ---------- | ----------------------------------------------------------------------------------------------------------- |
| 計算機誤差 | 計算の絶対値が, オーバー/アンダー フロー したときの誤差                                                     |
| 丸め誤差   | データ型の制限により, 以下の桁を丸めたときの誤差                                                            |
| 打切り誤差 | あるところで打ち切って近似値を求める場合に生じる誤差                                                        |
| 桁落ち     | 大きさが小さい２つの数の引き算時に, 有効桁数が減ることで生じる誤差                                          |
| 情報落ち   | 絶対値が非常に大きい数と小さい数を加減算するときに,<br />小さい数が計算に反映されないことによって生じる誤差 |

### ☆ 教科書問題

#### 情報落ちの確認

-   [例題１](./p94_r1.c)

#### 降順と昇順の加算結果の比較

-   [例題２](./p95_r2.c)

## 5-1 基本的なデータ構造

### ☆ 配列とレコードとは

複数のデータを効率よく処理するためのデータ同士の構成の方法として,

-   配列 (array)
-   レコード (record)
-   リスト (list)
-   スタック (stack)
    などの構造がある.

### ☆ さらに詳しく

#### 配列

配列の添字は, `0` から始まることが多いが, プログラム言語によっては `1` から始まる場合もある. (例: Lua とか)  
また, ２つ以上の添字を組み合わせて要素を指定する配列を **多次元配列 (multi-D array)** という.  
整数値以外の文字列などを添え字にできるものもあり, その配列を **連想配列 (associative array)** という.

```ts
type Direction = "east" | "west" | "south" | "north";

type DirectionArray = {
    [key: Direction]: string;
};

const directions: DirectionArray = {
    east: "東",
    west: "西",
    south: "南",
    north: "北",
}; // -> 連想配列

// directions['east'] -> '東'
```

#### レコード

異なるデータ型の複数の要素を１つにまとめたデータ構造を **レコード (record)** という.  
レコードの要素を指定する場合, 変数名と要素名を `.` で区切って `変数名.要素名` のように表現する.  
C 言語では, `struct` 文を使って構造体を定義する.

### ☆ 書き方

#### 配列

[こちらへ戻って, どうぞ](#書き方)

#### レコード

C 言語では, レコードを扱うデータ構造として, **構造体 (structure)** というデータ型が用意されている.
例えば, 平面上の座標を (x, y) で表すとき (-> `POINT`)のレコード点 (`point`) は次のようになる.

```c
struct POINT {
    int x;
    int y;
} point;
```

構造体の宣言とその変数は独立させることもできる.

```c
struct POINT {
    int x;
    int y;
};

struct POINT point;
```

また, 構造体の要素は次のように指定する.

```c
point.x = 10;
point.y = 20;
```

(まあ教科書の例が悪いんですけど)  
レコードでは, １つの構造体に **複数の型** を宣言できる ~~(だから使うんだよ. んじゃなければ配列で良いのよ)~~  
例えば, 遊園地に入場させるために,

-   お名前
-   身長
-   体重
-   年齢

の４つを１人の子の情報として持ちたいときに, 構造体(`PERSON`) を使う.

```c
struct PERSON {
    char *firstName[];
    char *lastName[];
    int height;
    int age;
};
```

例えば, ひょーどーの情報を持ち歩きたいとする. そういうときに構造体を継承して, `hyodo`を作ろう.

```c
struct PERSON hyodo = {
    "ひょーどー", "しゅんしゅん", 170, 17,
};
```

もう１人, たけぴ (`takepi`) が入園した. また, それも構造体を継承しよう.

```c
struct PERSON takepi = {
    ...
};
```

のように, 複数のオブジェクトの型を統一させるために使うと, それぞれのオブジェクトを配列に入れて,  
_for_ 文で回して名字だけ取るなどもできる. 嬉しいね.

### ☆ 教科書問題

#### 構造体配列への格納と一覧表示

-   [例題１](./p109_r1.c)
    -   [練習問題１](./p109_ren_1.c)
    -   [練習問題２](./p109_ren_2.c)

## 5-2 リストと木構造

### ☆ リスト・木構造とは

#### リスト

広い意味では, データを列挙した一覧表を **リスト (list)** と呼ぶ.

-   連結リスト: 前後のデータの位置を示す情報をもったデータ構造
-   双方向リスト: 先頭側から末尾側へも, 逆方向にも要素をたどっていくことができるデータ構造
-   循環リスト: 先頭や末尾が存在せず, 円環状に要素が繋がれているデータ構造

がある.

#### 木構造

会社の組織図やトーナメント表, フォルダに整理して保存したファイルなど,  
木のように枝分かれした形で整理すると扱いやすいデータがある.  
このようなデータ構造を **木構造 (tree)** といい, 実際の木をさまさまにした形で表現することが多い.

木構造は, データが格納される **節 (node)** と２つの節を結ぶ **枝 (branch)** から構成される.  
ある節からみてすぐ上にある節を **親 (parent)** といい, すぐ下にある節を **子 (child)** という.  
また, 親を持たない最も上にある節を **根 (root)** といい, 子を持たない末端の節を **葉 (leaf)** という.

木構造の中で, １つから出る枝が２つ以下のものを特に **２分木 (binary tree)** と呼ぶ.

![tree](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200117221520.gif)  
(ref: [工業大学生ももやまのうさぎ塾](https://www.momoyama-usagi.com/entry/info-algo-tree))

### ☆ さらに詳しく

#### リスト

連結リストでは, リストの個々の要素が収納される **データ部** と, 次の要素の位置を示す **参照部 (ポインタ/リンク)** という.
また, 先頭を示すポインタ (`HEAD`) と, 最後尾を示すヌル文字 (`NULL`) を入れることが多い.  
連結リストには次のような特徴がある.

-   データ数の増減が可能
-   データの追加・削除が容易
-   データを取る出すには, 先頭からたどらなければならない

これを実装する場合に, データ型としてリストが用意されていないとき,  
レコードと配列を使って連結リストを使って連結リストを実現することができる.

| 添字 | データ部 | 参照部 |
| ---- | -------- | ------ |
| 0    | _HEAD_   | 1      |
| 1    | `A`      | 2      |
| 2    | `B`      | 4      |
| 3    | `D`      | 5      |
| 4    | `C`      | 3      |
| 5    | `E`      | _NULL_ |
| 6    |          |        |

順番に取り出していくと, 次のようにデータを取り出すことができる:

> _HEAD_ → `A` → `B` → `C` → `D` → `E` → _NULL_

#### 木構造

表示などの処理をするために, ２分木からデータを取り出して, 節から順番に  
枝をなぞるように辿っていくことを **木の走査 (traversal)** という.  
木の走査は, 節と左右の部分木のなぞり方の順序には３つの種類がある.

-   **前順走査 (preorder traversal)**

    > 最初に節を走査し, 次に左の部分木を, 最後に右の部分木を操作する方法.  
    >  ![preorder-traversal](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200118192915.gif)  
    >  (ref: [工業大学生ももやまのうさぎ塾](https://www.momoyama-usagi.com/entry/info-algo-tree-traverse))

-   **間順走査 (inorder traversal)**

    > 最初に左の部分木を走査し, 次に節を, 最後に右の部分木を走査する方法.
    > ![inorder-traversal](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200118192923.gif)  
    >  (ref: [工業大学生ももやまのうさぎ塾](https://www.momoyama-usagi.com/entry/info-algo-tree-traverse))

-   **後順走査 (postorder traversal)**

    > 最初に左の部分木を走査し, 次に右の部分木を, 最後に節を完走する方法.
    > ![postorder-traversal](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200118192933.gif)  
    >  (ref: [工業大学生ももやまのうさぎ塾](https://www.momoyama-usagi.com/entry/info-algo-tree-traverse))

また, 走査したときに, 昇順または降順に整理にされている木を **順序木 (ordered tree)** という.

### ☆ 書き方

#### リスト

##### 連結リストの表示

手順:

1. 先頭データの位置が格納されている _HEAD_ の参照部を変数 `i` へ代入
2. 添字が `i` の配列のデータ部を取り出して, 表示する
3. 添字が `i` の参照部を取り出して, `i` へ代入
4. もし, `i` が終端を示す値 (_NULL_) でなければ, 2 へ戻って処理を繰り返し, _NULL_ なら終了

実装:

```c
void printList(int i)
{
    while (i != 0) // ここでは, 葉の終端参照を `0` としている.
    {
        printf("%c", Data[i].character);
        i = Data[i].nextIndex;
    }
    printf("\n");
}
```

([例題１](./p118_r1.c) から, 一部抜粋)

##### リスト最後尾へのデータの追加

手順:
現在使用している添字の最大値を `last` とする.

1. 先頭データの位置が格納されている _HEAD_ の参照部を変数 `i` へ代入
2. `i` を `j` に大入試, ここまでの最終添字を保存
3. 添字が `i` の配列の参照部を取り出し, `i` に代入
4. もし, `i` が終端を示す値 (_NULL_) でなければ, 2 に戻って処理を繰り返し, _NULL_ ならば, 5 へ進む
5. 変数 `last` の値を 1 増やす
6. 添字が `j` の配列の参照部に `last` を代入
7. 添字が `last` の配列のデータ部に追加するデータを代入
8. 添字が `last` の配列の参照部に, 終端を示す値 (_NULL_) を代入

実装:

```c
void addList(char c)
{
    int i, j;

    i = Data[0].nextIndex;
    while (i != 0) // ここでは, 葉の終端参照を `0` としている.
    {
        j = i;
        i = Data[i].nextIndex;
    }

    lastIndex++;
    Data[j].nextIndex = lastIndex;
    Data[lastIndex].character = c;
    Data[lastIndex].nextIndex = 0;
}
```

([例題１](./p118_r1.c) から, 一部抜粋)

#### 木構造

教科書では, 間順走査のみの紹介だったため, 間順走査のみの紹介である.

手順:

1.  左の部分木の葉であるところから開始する
2.  処理しようとする節が葉 (末端) ならば, 葉に書かれた値を返す
3.  葉でなければ, 左の部分木を処理したものと, 節に書かれた演算子と, 右の部分木を処理したものをつなぐ

実装:

```c
void printTree(int i)
{
    if (tree[i].leftPointer == -1) // ここでは, 葉の終端参照を `-1` としている.
    {
        printf("%c", tree[i].label);
    }
    else
    {
        printf("(");
        printTree(tree[i].leftPointer);
        printf("%c", tree[i].label);
        printTree(tree[i].rightPointer);
        printf(")");
    }
}
```

([例題２](./p120_r2.c) から, 一部抜粋)

### ☆ 教科書問題

#### 構造体の配列を使ったリストのプログラム

-   [例題１](./p118_r1.c)
    -   [練習問題](./p109_ren_1.c)
    -   [先生からの問題](./p109_ren_2.c)

#### ２分木に格納された文字の表示

-   [例題２](./p120_r2.c)
    -   [練習問題](./p121_ren.c)
